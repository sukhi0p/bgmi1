#include "include/Tools.h"
#include <XorStr.hpp>
#include "imgui/imgui.h"
#include "imgui/imgui_additional.h"
#include "imgui/backends/imgui_impl_android.h"
#include "imgui/backends/imgui_impl_opengl3.h"
#include "imgui/android_native_app_glue.h"
#include "KittyMemory/MemoryPatch.h"
#include "include/shader.h"
#include "include/obfuscate.h"
#include "And64InlineHook/And64InlineHook.hpp"
#include <include/Includes.h>
#include <json.hpp>
#include <unordered_set>
#include <GLES/gl.h>
#include <dlfcn.h>
#include <curl/curl.h>
#include <openssl/evp.h>
#include <openssl/pem.h>
#include <openssl/rsa.h>
#include <openssl/err.h>
#include <openssl/md5.h>
#include <curl/curl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fstream>
#include <string>
#include <fstream>
#include <mutex>
#include "include/shadowhook.h"

// ==================== ULTIMATE PROTECTION LAYERS ====================
// Layer 1: Anti-Detection Macros
#include <android/log.h>
#include <cstddef>
#include <sys/ptrace.h>
#include <link.h>
#include <elf.h>

#define LOG_TAG "UJJWAL"
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)
#define OBFUSCATE(str) str

// ==================== LAYER 2: ANTI-DEBUG & ANTI-TRACE ====================
class AntiDebug {
public:
    static void init() {
        // Anti-ptrace
        ptrace(PTRACE_TRACEME, 0, 0, 0);
        
        // Hide from debuggers
        FILE* fp = fopen("/proc/self/status", "r");
        if (fp) {
            char line[256];
            while (fgets(line, sizeof(line), fp)) {
                if (strstr(line, "TracerPid")) {
                    if (atoi(strchr(line, ':') + 1) != 0) {
                        fclose(fp);
                        exit(0);
                    }
                }
            }
            fclose(fp);
        }
    }
    
    static void checkDebugger() {
        if (ptrace(PTRACE_TRACEME, 0, 1, 0) < 0) {
            exit(0);
        }
    }
};

// ==================== LAYER 3: FILE INTEGRITY BYPASS ====================
class FileBypass {
public:
    static void protect() {
        // Remove all detection files
        system("rm -rf /data/data/com.pubg.imobile/files/ano_tmp");
        system("rm -rf /data/data/com.pubg.imobile/files/obblib");
        system("rm -rf /data/data/com.pubg.imobile/files/xlog");
        system("rm -rf /data/data/com.pubg.imobile/app_bugly");
        system("rm -rf /data/data/com.pubg.imobile/app_crashrecord");
        system("rm -rf /data/data/com.pubg.imobile/app_crashSight");
        
        // Create fake files with 000 permissions
        system("touch /data/data/com.pubg.imobile/files/ano_tmp");
        system("chmod 000 /data/data/com.pubg.imobile/files/ano_tmp");
        system("touch /data/data/com.pubg.imobile/files/obblib");
        system("chmod 000 /data/data/com.pubg.imobile/files/obblib");
        system("touch /data/data/com.pubg.imobile/files/xlog");
        system("chmod 000 /data/data/com.pubg.imobile/files/xlog");
    }
};

uintptr_t UE4;

//====================================||â€¢â€¢ Gnative Code â€¢â€¢||===================================

#define GNativeAndroidApp_Offset 0xdad0280

//====================================||â€¢â€¢ Permission Code â€¢â€¢||===================================
int screenWidth = -1, glWidth, screenHeight = -1, glHeight;
float density = -1;
bool initImGui = false;
bool fixblink = true;
bool WALLHACK = true;
bool CyanBody = false;
bool GreenBody = false;
bool RedEnemy = true;  // ðŸ”´ Enemy Red
bool GreenVehicle = true;  // ðŸŸ¢ Vehicle Green
bool isLowGraphicsMode = true;
bool useNewBlinkFix = true;

//====================================||â€¢â€¢ Shader Colors â€¢â€¢||===================================
#define ENEMY_RED_SHADER "float4 main() { return float4(1.0, 0.0, 0.0, 1.0); }"
#define VEHICLE_GREEN_SHADER "float4 main() { return float4(0.0, 1.0, 0.0, 1.0); }"
#define NORMAL_SHADER ""

std::unordered_set<GLuint> playerPrograms;
GLuint playerVertexShader = 0, playerMaskShader = 0;
std::mutex playerProgramsMutex;
std::mutex playerShaderMutex; 

std::unordered_set<GLuint> gunPrograms;
GLuint gunVertexShader = 0, gunMaskShader = 0;
std::mutex gunProgramsMutex;
std::mutex gunShaderMutex;

const char *Gamepackage = "com.pubg.imobile";
static char path[200];
static int currentItem = 0;
static char keyForLogin[64];

static std::string EXP = "KEY EXPIRY";

//====================================||â€¢â€¢ Utility Functions â€¢â€¢||===================================

bool isLibraryLoaded(const char* libName) {
    FILE* fp = fopen("/proc/self/maps", "r");
    if (!fp) return false;
    char line[512];
    while (fgets(line, sizeof(line), fp)) {
        if (strstr(line, libName)) {
            fclose(fp);
            return true;
        }
    }
    fclose(fp);
    return false;
}

std::string getDayName() {
    time_t now = time(0);
    tm *ltm = localtime(&now);
    const char* days[] = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
    return days[ltm->tm_wday];
}

std::string getAMPM() {
    time_t now = time(0);
    tm *ltm = localtime(&now);
    return (ltm->tm_hour < 12) ? "AM" : "PM";
}

//====================================||â€¢â€¢ Clipboard Functions â€¢â€¢||===================================

bool bValid = false;
std::string g_Token, g_Auth;
android_app *g_App = 0;
using json = nlohmann::ordered_json;

std::string getClipboardText() {
    if (!g_App) return "";
    auto activity = g_App->activity;
    if (!activity) return "";
    auto vm = activity->vm;
    if (!vm) return "";
    auto object = activity->clazz;
    if (!object) return "";
    
    std::string result;
    JNIEnv *env;
    vm->AttachCurrentThread(&env, 0); 
    {
        auto ContextClass = env->FindClass("android/content/Context");
        auto getSystemServiceMethod = env->GetMethodID(ContextClass, "getSystemService", "(Ljava/lang/String;)Ljava/lang/Object;");
        auto str = env->NewStringUTF("clipboard");
        auto clipboardManager = env->CallObjectMethod(object, getSystemServiceMethod, str);
        env->DeleteLocalRef(str);
        
        auto ClipboardManagerClass = env->FindClass("android/content/ClipboardManager");
        auto getText = env->GetMethodID(ClipboardManagerClass, "getText", "()Ljava/lang/CharSequence;");
        auto CharSequenceClass = env->FindClass("java/lang/CharSequence");
        auto toStringMethod = env->GetMethodID(CharSequenceClass, "toString", "()Ljava/lang/String;");
        auto text = env->CallObjectMethod(clipboardManager, getText);
        
        if (text) {
            str = (jstring) env->CallObjectMethod(text, toStringMethod);
            result = env->GetStringUTFChars(str, 0);
            env->DeleteLocalRef(str);
            env->DeleteLocalRef(text);
        }
        
        env->DeleteLocalRef(CharSequenceClass);
        env->DeleteLocalRef(ClipboardManagerClass);
        env->DeleteLocalRef(clipboardManager);
        env->DeleteLocalRef(ContextClass);
    }
    vm->DetachCurrentThread();
    return result;
}

//====================================||â€¢â€¢ Message Box â€¢â€¢||===================================

std::u16string stringToUtf16(const std::string& str) {
    std::wstring_convert<std::codecvt_utf8_utf16<char16_t>, char16_t> converter;
    return converter.from_bytes(str);
}

std::unique_ptr<char16_t[]> stringToChar16Array(const std::string& str) {
    std::u16string utf16str = stringToUtf16(str);
    std::unique_ptr<char16_t[]> char16Array(new char16_t[utf16str.size() + 1]);
    std::copy(utf16str.begin(), utf16str.end(), char16Array.get());
    char16Array[utf16str.size()] = u'\0';
    return char16Array;
}

int (*CMessageBoxExt)(int type, const char16_t* Caption, const char16_t* Text);

int MsgBox(int Method, const std::string& Caption, const std::string& Text) {
    auto caption = stringToChar16Array(Caption);
    auto text = stringToChar16Array(Text);
    return CMessageBoxExt(Method, caption.get(), text.get());
}

//====================================||â€¢â€¢ OpenGL Hooks â€¢â€¢||===================================

static void (*oglViewport)(GLint x, GLint y, GLsizei width, GLsizei height);
static void (*oglDrawElements)(GLenum mode, GLsizei count, GLenum type, const void *indices);
static void (*oglShaderSource)(GLuint shader, GLsizei count, const GLchar **string, const GLint *length);
static void (*oglAttachShader)(GLuint program, GLuint shader);

static GLint g_offsetX = 17;
static GLint g_offsetY = 0;

void _glViewport(GLint x, GLint y, GLsizei width, GLsizei height) {
    if (x == 0 && y == 0 && width > 1000 && height > 500) {
        screenWidth = width;
        screenHeight = height;
    }

    if (fixblink && screenWidth > 0 && screenHeight > 0) {
        GLint adjustedWidth = screenWidth - 2 * g_offsetX;
        GLint adjustedHeight = screenHeight - 2 * g_offsetY;
        glDisable(GL_SCISSOR_TEST);
        glDisable(GL_STENCIL_TEST);
        oglViewport(g_offsetX, g_offsetY, adjustedWidth, adjustedHeight);
    } else {
        oglViewport(x, y, width, height);
    }
}

void _glDrawElements(GLenum mode, GLsizei count, GLenum type, const void *indices) {
    if (WALLHACK) {
        GLuint currentProgram = 0;
        glGetIntegerv(GL_CURRENT_PROGRAM, (GLint *)&currentProgram);

        std::lock_guard<std::mutex> lock(playerProgramsMutex);
        if (playerPrograms.find(currentProgram) == playerPrograms.end()) {
            oglDrawElements(mode, count, type, indices);
            return;
        }

        GLfloat depthRange[2];
        glGetFloatv(GL_DEPTH_RANGE, depthRange);
        GLboolean colorMask[4];
        glGetBooleanv(GL_COLOR_WRITEMASK, colorMask);
        GLboolean wasBlend = glIsEnabled(GL_BLEND);
        
        if (!wasBlend) glEnable(GL_BLEND);
        glDepthRangef(1.0f, 0.0f);
        glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
        oglDrawElements(mode, count, type, indices);
        glDepthRangef(depthRange[0], depthRange[1]);
        glColorMask(colorMask[0], colorMask[1], colorMask[2], colorMask[3]);
        if (!wasBlend) glDisable(GL_BLEND);
        return;
    }

    oglDrawElements(mode, count, type, indices);
}

//============================||â€¢â€¢ SHADER - ENEMY RED & VEHICLE GREEN â€¢â€¢||======================================

void _glShaderSource(GLuint shader, GLsizei count, const GLchar **string, const GLint *length) {
    if (!string || !*string || count <= 0) {
        oglShaderSource(shader, count, string, length);
        return;
    }

    oglShaderSource(shader, count, string, length);

    // ðŸ”´ ENEMY RED SHADER
    if (RedEnemy && (
        strstr(*string, _enc("Master_Mask_Base/TGPUSkinVertexFactory")) ||
        strstr(*string, _enc("Master_Mask/TGPUSkinVertexFactory")) ||
        strstr(*string, _enc("Master_Mask_Base_V2/TGPUSkinVertexFactory")) ||
        strstr(*string, _enc("Master_Mask_Base_BpOnly/TGPUSkinVertexFactory")) ||
        strstr(*string, _enc("Master_Mask_Base/FLocalVertexFactory")) ||
        strstr(*string, _enc("Master_Mask/FLocalVertexFactory")) ||
        strstr(*string, _enc("Master_Mask_Base_V2/FLocalVertexFactory")) ||
        strstr(*string, _enc("Master_Mask_Base_BpOnly/FLocalVertexFactory")) ||
        strstr(*string, _enc("Master_Mask_Base")) ||
        strstr(*string, _enc("Master_Mask")) ||
        strstr(*string, _enc("Master_Mask_Base_BPOnly")) ||
        strstr(*string, _enc("BP_PlayerPawn")) ||
        strstr(*string, _enc("Char_")) ||
        strstr(*string, _enc("Avatar_")) ||
        strstr(*string, _enc("Skin_")) ||
        strstr(*string, _enc("cloth")) ||
        strstr(*string, _enc("thumb")) ||
        strstr(*string, _enc("spine_01")) ||
        strstr(*string, _enc("spine_02")) ||
        strstr(*string, _enc("spine_03")) ||
        strstr(*string, _enc("head")) ||
        strstr(*string, _enc("hair")) ||
        strstr(*string, _enc("Characters")) ||
        strstr(*string, _enc("_Body_")) ||
        strstr(*string, _enc("Outfit_")) ||
        strstr(*string, _enc("Helmet_")) ||
        strstr(*string, _enc("Backpack_")) ||
        strstr(*string, _enc("Vest_")) ||
        strstr(*string, _enc("Armor_")) ||
        strstr(*string, _enc("Glove_")) ||
        strstr(*string, _enc("cloth/TGPUSkinVertexFactory")) ||
        strstr(*string, _enc("thumb/TGPUSkinVertexFactory")) ||
        strstr(*string, _enc("spine_01/TGPUSkinVertexFactory")) ||
        strstr(*string, _enc("spine_02/TGPUSkinVertexFactory")) ||
        strstr(*string, _enc("head/TGPUSkinVertexFactory")) ||
        strstr(*string, _enc("hair/TGPUSkinVertexFactory")) ||
        strstr(*string, _enc("Characters/TGPUSkinVertexFactory")) ||
        strstr(*string, _enc("Player_")) ||
        strstr(*string, _enc("Custom_Master_Mask_NewMask")))) 
    {
        GLenum shaderType;
        glGetShaderiv(shader, GL_SHADER_TYPE, (GLint*)&shaderType);
        if (shaderType == GL_FRAGMENT_SHADER) {
            std::lock_guard<std::mutex> lock{playerShaderMutex};
            playerMaskShader = shader;
            *string = ENEMY_RED_SHADER;
            LOGI("ðŸ”´ Enemy Red Shader Applied");
        }
    }

    // ðŸŸ¢ VEHICLE GREEN SHADER
    if (GreenVehicle && (
        strstr(*string, _enc("Master_VH_IBL/TGPUSkinVertexFactorytrue")) || 
        strstr(*string, _enc("Master_VH_Base/TGPUSkinVertexFactorytrue")) || 
        strstr(*string, _enc("Master_VH_IBL_SeparateSDW/TGPUSkinVertexFactorytrue")) || 
        strstr(*string, _enc("Master_VH_IBL_SeparateSDW/TGPUSkinVertexFactoryfalse")) || 
        strstr(*string, _enc("Master_VH_IBL/TGPUSkinVertexFactoryfalse")) || 
        strstr(*string, _enc("Master_VH_Base/TGPUSkinVertexFactoryfalse")) ||
        strstr(*string, _enc("Vehicle")) ||
        strstr(*string, _enc("Car_")) ||
        strstr(*string, _enc("UAZ")) ||
        strstr(*string, _enc("Dacia")) ||
        strstr(*string, _enc("Buggy")) ||
        strstr(*string, _enc("Motor")) ||
        strstr(*string, _enc("Boat")) ||
        strstr(*string, _enc("PG117")) ||
        strstr(*string, _enc("Mirado")) ||
        strstr(*string, _enc("Rony")) ||
        strstr(*string, _enc("Scooter")))) 
    {
        GLenum shaderType;
        glGetShaderiv(shader, GL_SHADER_TYPE, (GLint*)&shaderType);
        if (shaderType == GL_FRAGMENT_SHADER) {
            std::lock_guard<std::mutex> lock{playerShaderMutex};
            playerMaskShader = shader;
            *string = VEHICLE_GREEN_SHADER;
            LOGI("ðŸŸ¢ Vehicle Green Shader Applied");
        }
    }

    return;
}

void _glAttachShader(GLuint program, GLuint shader) {
    std::unique_lock<std::mutex> ulock{playerShaderMutex};
    if (shader == playerVertexShader || shader == playerMaskShader) {
        ulock.unlock();
        std::lock_guard<std::mutex> lock{playerProgramsMutex};
        playerPrograms.insert(program);
    }
    return oglAttachShader(program, shader);
}

//====================================||â€¢â€¢ LAYER 4: CRITICAL BYPASS PATCHES â€¢â€¢||==================================

void applyCriticalBypasses() {
    LOGI("ðŸ”¥ APPLYING CRITICAL BYPASS PATCHES...");
    
    // Wait for libraries
    while (!isLibraryLoaded("libanogs.so") || !isLibraryLoaded("libhdmpve.so")) {
        sleep(1);
    }
    
    // libanogs.so patches (Anti-cheat main)
    LOGI("ðŸ“Œ Patching libanogs.so...");
    MemoryPatch::createWithHex("libanogs.so", 0x1C1430, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(30000);
    MemoryPatch::createWithHex("libanogs.so", 0x1C1444, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(30000);
    MemoryPatch::createWithHex("libanogs.so", 0x1C1634, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(30000);
    MemoryPatch::createWithHex("libanogs.so", 0x1C16DC, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(30000);
    MemoryPatch::createWithHex("libanogs.so", 0x1C16F0, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(30000);
    MemoryPatch::createWithHex("libanogs.so", 0x1C1758, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(30000);
    MemoryPatch::createWithHex("libanogs.so", 0x2234B0, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(30000);
    MemoryPatch::createWithHex("libanogs.so", 0x228168, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(30000);
    MemoryPatch::createWithHex("libanogs.so", 0x29BF24, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(30000);
    MemoryPatch::createWithHex("libanogs.so", 0x2FE80C, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(30000);
    MemoryPatch::createWithHex("libanogs.so", 0x2FE824, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(30000);
    MemoryPatch::createWithHex("libanogs.so", 0x2E1844, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(30000);
    MemoryPatch::createWithHex("libanogs.so", 0x2FE85C, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(30000);
    MemoryPatch::createWithHex("libanogs.so", 0x2FE984, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(30000);
    MemoryPatch::createWithHex("libanogs.so", 0x2FEA18, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(30000);
    MemoryPatch::createWithHex("libanogs.so", 0x2FEA28, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(30000);
    MemoryPatch::createWithHex("libanogs.so", 0x2FEABC, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(30000);
    MemoryPatch::createWithHex("libanogs.so", 0x2FEBD4, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(30000);
    MemoryPatch::createWithHex("libanogs.so", 0x330494, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(30000);
    MemoryPatch::createWithHex("libanogs.so", 0x36A5B8, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(30000);
    MemoryPatch::createWithHex("libanogs.so", 0x39F56C, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(30000);
    MemoryPatch::createWithHex("libanogs.so", 0x3A4CCC, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(30000);
    MemoryPatch::createWithHex("libanogs.so", 0x461F04, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(30000);
    MemoryPatch::createWithHex("libanogs.so", 0x4633F4, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(30000);
    MemoryPatch::createWithHex("libanogs.so", 0x471B68, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(30000);
    MemoryPatch::createWithHex("libanogs.so", 0x47B5CC, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(30000);
    MemoryPatch::createWithHex("libanogs.so", 0x4D1DD0, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(30000);
    MemoryPatch::createWithHex("libanogs.so", 0x4D4C94, "00 00 80 D2 C0 03 5F D6").Modify();
    
    LOGI("âœ… libanogs.so patched (28 patches)");
    usleep(100000);
    
    // libhdmpve.so patches (ACE Anti-cheat)
    LOGI("ðŸ“Œ Patching libhdmpve.so...");
    MemoryPatch::createWithHex("libhdmpve.so", 0x9bef0, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(30000);
    MemoryPatch::createWithHex("libhdmpve.so", 0x9c950, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(30000);
    MemoryPatch::createWithHex("libhdmpve.so", 0x9d568, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(30000);
    MemoryPatch::createWithHex("libhdmpve.so", 0x9dffc, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(30000);
    MemoryPatch::createWithHex("libhdmpve.so", 0x9ea3c, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(30000);
    MemoryPatch::createWithHex("libhdmpve.so", 0x9f524, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(30000);
    MemoryPatch::createWithHex("libhdmpve.so", 0xa011c, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(30000);
    MemoryPatch::createWithHex("libhdmpve.so", 0xa1fc4, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(30000);
    MemoryPatch::createWithHex("libhdmpve.so", 0xa2cc4, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(30000);
    MemoryPatch::createWithHex("libhdmpve.so", 0xa3a40, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(30000);
    MemoryPatch::createWithHex("libhdmpve.so", 0xa43f4, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(30000);
    MemoryPatch::createWithHex("libhdmpve.so", 0xa4c24, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(30000);
    MemoryPatch::createWithHex("libhdmpve.so", 0xa54c8, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(30000);
    MemoryPatch::createWithHex("libhdmpve.so", 0xa5c6c, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(30000);
    MemoryPatch::createWithHex("libhdmpve.so", 0xa797c, "00 00 80 D2 C0 03 5F D6").Modify();
    
    LOGI("âœ… libhdmpve.so patched (15 patches)");
    
    // libUE4.so critical patches (safe ones only)
    LOGI("ðŸ“Œ Patching libUE4.so critical...");
    MemoryPatch::createWithHex("libUE4.so", 0xab351a4, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(50000);
    MemoryPatch::createWithHex("libUE4.so", 0xab7613c, "00 00 80 D2 C0 03 5F D6").Modify();
    usleep(50000);
    MemoryPatch::createWithHex("libUE4.so", 0xac0e2c4, "00 00 80 D2 C0 03 5F D6").Modify();
    
    LOGI("ðŸ”¥ TOTAL BYPASS PATCHES: 46");
}

//====================================||â€¢â€¢ LAYER 5: ANTI-SCREENSHOT & ANTI-RECORD â€¢â€¢||==================================

void antiScreenshot() {
    system("settings put global overlay_display_devices none");
    system("settings put secure show_rotation_suggestions 0");
    system("settings put global development_settings_enabled 0");
}

//====================================||â€¢â€¢ MAIN THREAD â€¢â€¢||==================================

void *main_thread(void *) {
    // Layer 2: Anti-Debug
    AntiDebug::init();
    
    UE4 = Tools::GetBaseAddress("libUE4.so");
    while (!UE4) {
        UE4 = Tools::GetBaseAddress("libUE4.so");
        sleep(1);
    }
    
    while (!g_App) {
        g_App = *(android_app **) (UE4 + GNativeAndroidApp_Offset);
        sleep(1);
    }

    // Layer 3: File Bypass
    FileBypass::protect();
    
    // Layer 4: Critical Bypasses
    applyCriticalBypasses();
    
    // Layer 5: Anti-Screenshot
    antiScreenshot();

    // ShadowHook initialization
    shadowhook_init(SHADOWHOOK_MODE_UNIQUE, 0);
    shadowhook_hook_sym_name("libGLESv2.so", "glViewport", (void*)_glViewport, (void**)&oglViewport);
    shadowhook_hook_sym_name("libGLESv2.so", "glDrawElements", (void*)_glDrawElements, (void**)&oglDrawElements);
    shadowhook_hook_sym_name("libGLESv2.so", "glShaderSource", (void*)_glShaderSource, (void**)&oglShaderSource);
    shadowhook_hook_sym_name("libGLESv2.so", "glAttachShader", (void*)_glAttachShader, (void**)&oglAttachShader);

    return 0;
}

//====================================||â€¢â€¢ LOGIN THREAD â€¢â€¢||==================================

void ClearClipboard(android_app* app) {
    if (!app || !app->activity) return;
    
    JNIEnv* env;
    app->activity->vm->AttachCurrentThread(&env, NULL);
    
    jclass clipboardClass = env->FindClass("android/content/ClipboardManager");
    if (!clipboardClass) {
        app->activity->vm->DetachCurrentThread();
        return;
    }
    
    jmethodID hasPrimaryClip = env->GetMethodID(clipboardClass, "hasPrimaryClip", "()Z");
    if (!hasPrimaryClip) {
        env->DeleteLocalRef(clipboardClass);
        app->activity->vm->DetachCurrentThread();
        return;
    }
    
    jmethodID clearPrimaryClip = env->GetMethodID(clipboardClass, "clearPrimaryClip", "()V");
    if (!clearPrimaryClip) {
        env->DeleteLocalRef(clipboardClass);
        app->activity->vm->DetachCurrentThread();
        return;
    }
    
    jclass contextClass = env->FindClass("android/content/Context");
    if (!contextClass) {
        env->DeleteLocalRef(clipboardClass);
        app->activity->vm->DetachCurrentThread();
        return;
    }
    
    jmethodID getSystemService = env->GetMethodID(contextClass, "getSystemService", "(Ljava/lang/String;)Ljava/lang/Object;");
    if (!getSystemService) {
        env->DeleteLocalRef(clipboardClass);
        env->DeleteLocalRef(contextClass);
        app->activity->vm->DetachCurrentThread();
        return;
    }
    
    jstring serviceName = env->NewStringUTF("clipboard");
    jobject clipboard = env->CallObjectMethod(app->activity->clazz, getSystemService, serviceName);
    
    if (!clipboard) {
        env->DeleteLocalRef(serviceName);
        env->DeleteLocalRef(clipboardClass);
        env->DeleteLocalRef(contextClass);
        app->activity->vm->DetachCurrentThread();
        return;
    }
    
    jboolean hasContent = env->CallBooleanMethod(clipboard, hasPrimaryClip);
    if (!hasContent) {
        env->CallVoidMethod(clipboard, clearPrimaryClip);
    }
    
    env->DeleteLocalRef(serviceName);
    env->DeleteLocalRef(clipboard);
    env->DeleteLocalRef(clipboardClass);
    env->DeleteLocalRef(contextClass);
    app->activity->vm->DetachCurrentThread();
}

void createDirectoryIfNeeded(const std::string &path) {
    struct stat info;
    if (stat(path.c_str(), &info) != 0) {
        if (mkdir(path.c_str(), 0777) != 0) {
            std::cerr << "Failed to create directory: " << path << std::endl;
            exit(1);
        }
    }
}

bool fileExists(const std::string &path) {
    struct stat buffer;
    return (stat(path.c_str(), &buffer) == 0);
}

std::string Login(const std::string &key) {
    return "OK";
}

void* LoginThread(void* arg) {
    std::string Filepath = "/sdcard/Android/obb/com.pubg.imobile/key.lic";
    std::string DirectoryPath = "/sdcard/Android/obb/com.pubg.imobile/";
    
    while (!g_App || !UE4) {
        sleep(1);
    }
    
    uintptr_t CMessageBoxExt_address = UE4 + 0x79CDCEC;
    CMessageBoxExt = reinterpret_cast<int(*)(int, const char16_t*, const char16_t*)>(CMessageBoxExt_address);
    createDirectoryIfNeeded(DirectoryPath);
    
    if (!fileExists(Filepath)) {
        ClearClipboard(g_App);
        MsgBox(0, "Please copy your key to clipboard", "Key Required");
        sleep(2);
        
        std::string ClipboardText;
        int attempts = 0;
        while (attempts < 3) {
            ClipboardText = getClipboardText();
            if (!ClipboardText.empty()) break;
            sleep(1);
            attempts++;
        }

        if (ClipboardText.empty()) {
            MsgBox(0, "No key found. Please copy your key first.", "Error");
            return nullptr;
        }

        std::ofstream keyFile(Filepath);
        if (!keyFile) {
            MsgBox(0, "Failed to create key file", "Error");
            return nullptr;
        }
        keyFile << ClipboardText;
        keyFile.close();
    }
    
    char keyForLogin[64];
    std::string fileContent;
    {
        std::ifstream inputFile(Filepath);
        if (!inputFile) {
            MsgBox(0, "Failed to open key file", "Error");
            return nullptr;
        }
        fileContent.assign((std::istreambuf_iterator<char>(inputFile)),
                          std::istreambuf_iterator<char>());
        inputFile.close();
        
        fileContent.erase(0, fileContent.find_first_not_of(" \n\r\t"));
        fileContent.erase(fileContent.find_last_not_of(" \n\r\t") + 1);
        
        if (fileContent.empty()) {
            MsgBox(0, "Key file is empty or invalid", "Error");
            system("rm -rf /sdcard/Android/obb/com.pubg.imobile/key.lic");
            return nullptr;
        }
    }
    
    strncpy(keyForLogin, fileContent.c_str(), sizeof(keyForLogin) - 1);
    keyForLogin[sizeof(keyForLogin) - 1] = '\0';

    std::string Keystatus = Login(keyForLogin);
    if (Keystatus == "OK") {
        if (bValid && g_Auth == g_Token) {
            return nullptr; 
        }
        MsgBox(0, "Validation failed. Please try again.", "Error");
    } else {
        MsgBox(0, Keystatus.c_str(), "Login Failed");
    }
    
    system("rm -rf /sdcard/Android/obb/com.pubg.imobile/key.lic");
    exit(EXIT_FAILURE);
    return nullptr;
}

//====================================||â€¢â€¢ CONSTRUCTOR - ENTRY POINT â€¢â€¢||==================================

__attribute__((constructor)) void _init() {
    pthread_t t1, t2, t3;
    
    // Start main thread
    pthread_create(&t1, 0, main_thread, 0);
    
    // Start bypass thread (separate for stability)
    pthread_create(&t2, 0, [](void*) -> void* {
        applyCriticalBypasses();
        return nullptr;
    }, 0);
    
    // Optional login thread
    // pthread_create(&t3, NULL, LoginThread, NULL);
    
    LOGI("ðŸ”¥ UJJWAL ULTIMATE BYPASS LOADED - BGMI CAN'T DETECT!");
}